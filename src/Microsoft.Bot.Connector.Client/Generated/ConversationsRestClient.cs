// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Microsoft.Bot.Connector.Client.Models;

namespace Microsoft.Bot.Connector.Client
{
    internal partial class ConversationsRestClient
    {
        private Uri endpoint;
        private ClientDiagnostics _clientDiagnostics;
        private HttpPipeline _pipeline;

        /// <summary> Initializes a new instance of ConversationsRestClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="endpoint"> server parameter. </param>
        public ConversationsRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Uri endpoint = null)
        {
            endpoint ??= new Uri("https://api.botframework.com");

            this.endpoint = endpoint;
            _clientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
        }

        internal HttpMessage CreateGetConversationsRequest(string continuationToken)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendPath("/v3/conversations", false);
            if (continuationToken != null)
            {
                uri.AppendQuery("continuationToken", continuationToken, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        /// <summary>
        /// List the Conversations in which this bot has participated.
        /// 
        /// 
        /// 
        /// GET from this method with a skip token
        /// 
        /// 
        /// 
        /// The return value is a ConversationsResult, which contains an array of ConversationMembers and a skip token.  If the skip token is not empty, then
        /// 
        /// there are further values to be returned. Call this method again with the returned token to get more values.
        /// 
        /// 
        /// 
        /// Each ConversationMembers object contains the ID of the conversation and an array of ChannelAccounts that describe the members of the conversation.
        /// </summary>
        /// <param name="continuationToken"> skip or continuation token. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<Response<ConversationsResult>> GetConversationsAsync(string continuationToken = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateGetConversationsRequest(continuationToken);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ConversationsResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = ConversationsResult.DeserializeConversationsResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// List the Conversations in which this bot has participated.
        /// 
        /// 
        /// 
        /// GET from this method with a skip token
        /// 
        /// 
        /// 
        /// The return value is a ConversationsResult, which contains an array of ConversationMembers and a skip token.  If the skip token is not empty, then
        /// 
        /// there are further values to be returned. Call this method again with the returned token to get more values.
        /// 
        /// 
        /// 
        /// Each ConversationMembers object contains the ID of the conversation and an array of ChannelAccounts that describe the members of the conversation.
        /// </summary>
        /// <param name="continuationToken"> skip or continuation token. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public Response<ConversationsResult> GetConversations(string continuationToken = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateGetConversationsRequest(continuationToken);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ConversationsResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = ConversationsResult.DeserializeConversationsResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateCreateConversationRequest(ConversationParameters parameters)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendPath("/v3/conversations", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(parameters);
            request.Content = content;
            return message;
        }

        /// <summary>
        /// Create a new Conversation.
        /// 
        /// 
        /// 
        /// POST to this method with a
        /// 
        /// * Bot being the bot creating the conversation
        /// 
        /// * IsGroup set to true if this is not a direct message (default is false)
        /// 
        /// * Array containing the members to include in the conversation
        /// 
        /// 
        /// 
        /// The return value is a ResourceResponse which contains a conversation id which is suitable for use
        /// 
        /// in the message payload and REST API uris.
        /// 
        /// 
        /// 
        /// Most channels only support the semantics of bots initiating a direct message conversation.  An example of how to do that would be:
        /// 
        /// 
        /// 
        /// ```
        /// 
        /// var resource = await connector.conversations.CreateConversation(new ConversationParameters(){ Bot = bot, members = new ChannelAccount[] { new ChannelAccount(&quot;user1&quot;) } );
        /// 
        /// await connect.Conversations.SendToConversationAsync(resource.Id, new Activity() ... ) ;
        /// 
        /// 
        /// 
        /// ```.
        /// </summary>
        /// <param name="parameters"> Parameters to create the conversation from. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="parameters"/> is null. </exception>
        public async Task<Response<ConversationResourceResponse>> CreateConversationAsync(ConversationParameters parameters, CancellationToken cancellationToken = default)
        {
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var message = CreateCreateConversationRequest(parameters);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                case 202:
                    {
                        ConversationResourceResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = ConversationResourceResponse.DeserializeConversationResourceResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Create a new Conversation.
        /// 
        /// 
        /// 
        /// POST to this method with a
        /// 
        /// * Bot being the bot creating the conversation
        /// 
        /// * IsGroup set to true if this is not a direct message (default is false)
        /// 
        /// * Array containing the members to include in the conversation
        /// 
        /// 
        /// 
        /// The return value is a ResourceResponse which contains a conversation id which is suitable for use
        /// 
        /// in the message payload and REST API uris.
        /// 
        /// 
        /// 
        /// Most channels only support the semantics of bots initiating a direct message conversation.  An example of how to do that would be:
        /// 
        /// 
        /// 
        /// ```
        /// 
        /// var resource = await connector.conversations.CreateConversation(new ConversationParameters(){ Bot = bot, members = new ChannelAccount[] { new ChannelAccount(&quot;user1&quot;) } );
        /// 
        /// await connect.Conversations.SendToConversationAsync(resource.Id, new Activity() ... ) ;
        /// 
        /// 
        /// 
        /// ```.
        /// </summary>
        /// <param name="parameters"> Parameters to create the conversation from. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="parameters"/> is null. </exception>
        public Response<ConversationResourceResponse> CreateConversation(ConversationParameters parameters, CancellationToken cancellationToken = default)
        {
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var message = CreateCreateConversationRequest(parameters);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                case 202:
                    {
                        ConversationResourceResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = ConversationResourceResponse.DeserializeConversationResourceResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateSendToConversationRequest(string conversationId, Activity activity)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendPath("/v3/conversations/", false);
            uri.AppendPath(conversationId, true);
            uri.AppendPath("/activities", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(activity);
            request.Content = content;
            return message;
        }

        /// <summary>
        /// This method allows you to send an activity to the end of a conversation.
        /// 
        /// 
        /// 
        /// This is slightly different from ReplyToActivity().
        /// 
        /// * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.
        /// 
        /// * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.
        /// 
        /// 
        /// 
        /// Use ReplyToActivity when replying to a specific activity in the conversation.
        /// 
        /// 
        /// 
        /// Use SendToConversation in all other cases.
        /// </summary>
        /// <param name="conversationId"> Conversation ID. </param>
        /// <param name="activity"> Activity to send. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="conversationId"/> or <paramref name="activity"/> is null. </exception>
        public async Task<Response<ResourceResponse>> SendToConversationAsync(string conversationId, Activity activity, CancellationToken cancellationToken = default)
        {
            if (conversationId == null)
            {
                throw new ArgumentNullException(nameof(conversationId));
            }
            if (activity == null)
            {
                throw new ArgumentNullException(nameof(activity));
            }

            using var message = CreateSendToConversationRequest(conversationId, activity);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                case 202:
                    {
                        ResourceResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = ResourceResponse.DeserializeResourceResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// This method allows you to send an activity to the end of a conversation.
        /// 
        /// 
        /// 
        /// This is slightly different from ReplyToActivity().
        /// 
        /// * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.
        /// 
        /// * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.
        /// 
        /// 
        /// 
        /// Use ReplyToActivity when replying to a specific activity in the conversation.
        /// 
        /// 
        /// 
        /// Use SendToConversation in all other cases.
        /// </summary>
        /// <param name="conversationId"> Conversation ID. </param>
        /// <param name="activity"> Activity to send. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="conversationId"/> or <paramref name="activity"/> is null. </exception>
        public Response<ResourceResponse> SendToConversation(string conversationId, Activity activity, CancellationToken cancellationToken = default)
        {
            if (conversationId == null)
            {
                throw new ArgumentNullException(nameof(conversationId));
            }
            if (activity == null)
            {
                throw new ArgumentNullException(nameof(activity));
            }

            using var message = CreateSendToConversationRequest(conversationId, activity);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                case 202:
                    {
                        ResourceResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = ResourceResponse.DeserializeResourceResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateSendConversationHistoryRequest(string conversationId, Transcript history)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendPath("/v3/conversations/", false);
            uri.AppendPath(conversationId, true);
            uri.AppendPath("/activities/history", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(history);
            request.Content = content;
            return message;
        }

        /// <summary>
        /// This method allows you to upload the historic activities to the conversation.
        /// 
        /// 
        /// 
        /// Sender must ensure that the historic activities have unique ids and appropriate timestamps. The ids are used by the client to deal with duplicate activities and the timestamps are used by the client to render the activities in the right order.
        /// </summary>
        /// <param name="conversationId"> Conversation ID. </param>
        /// <param name="history"> Historic activities. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="conversationId"/> or <paramref name="history"/> is null. </exception>
        public async Task<Response<ResourceResponse>> SendConversationHistoryAsync(string conversationId, Transcript history, CancellationToken cancellationToken = default)
        {
            if (conversationId == null)
            {
                throw new ArgumentNullException(nameof(conversationId));
            }
            if (history == null)
            {
                throw new ArgumentNullException(nameof(history));
            }

            using var message = CreateSendConversationHistoryRequest(conversationId, history);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                case 202:
                    {
                        ResourceResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = ResourceResponse.DeserializeResourceResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// This method allows you to upload the historic activities to the conversation.
        /// 
        /// 
        /// 
        /// Sender must ensure that the historic activities have unique ids and appropriate timestamps. The ids are used by the client to deal with duplicate activities and the timestamps are used by the client to render the activities in the right order.
        /// </summary>
        /// <param name="conversationId"> Conversation ID. </param>
        /// <param name="history"> Historic activities. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="conversationId"/> or <paramref name="history"/> is null. </exception>
        public Response<ResourceResponse> SendConversationHistory(string conversationId, Transcript history, CancellationToken cancellationToken = default)
        {
            if (conversationId == null)
            {
                throw new ArgumentNullException(nameof(conversationId));
            }
            if (history == null)
            {
                throw new ArgumentNullException(nameof(history));
            }

            using var message = CreateSendConversationHistoryRequest(conversationId, history);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                case 202:
                    {
                        ResourceResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = ResourceResponse.DeserializeResourceResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateUpdateActivityRequest(string conversationId, string activityId, Activity activity)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendPath("/v3/conversations/", false);
            uri.AppendPath(conversationId, true);
            uri.AppendPath("/activities/", false);
            uri.AppendPath(activityId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(activity);
            request.Content = content;
            return message;
        }

        /// <summary>
        /// Edit an existing activity.
        /// 
        /// 
        /// 
        /// Some channels allow you to edit an existing activity to reflect the new state of a bot conversation.
        /// 
        /// 
        /// 
        /// For example, you can remove buttons after someone has clicked &quot;Approve&quot; button.
        /// </summary>
        /// <param name="conversationId"> Conversation ID. </param>
        /// <param name="activityId"> activityId to update. </param>
        /// <param name="activity"> replacement Activity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="conversationId"/>, <paramref name="activityId"/>, or <paramref name="activity"/> is null. </exception>
        public async Task<Response<ResourceResponse>> UpdateActivityAsync(string conversationId, string activityId, Activity activity, CancellationToken cancellationToken = default)
        {
            if (conversationId == null)
            {
                throw new ArgumentNullException(nameof(conversationId));
            }
            if (activityId == null)
            {
                throw new ArgumentNullException(nameof(activityId));
            }
            if (activity == null)
            {
                throw new ArgumentNullException(nameof(activity));
            }

            using var message = CreateUpdateActivityRequest(conversationId, activityId, activity);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                case 202:
                    {
                        ResourceResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = ResourceResponse.DeserializeResourceResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Edit an existing activity.
        /// 
        /// 
        /// 
        /// Some channels allow you to edit an existing activity to reflect the new state of a bot conversation.
        /// 
        /// 
        /// 
        /// For example, you can remove buttons after someone has clicked &quot;Approve&quot; button.
        /// </summary>
        /// <param name="conversationId"> Conversation ID. </param>
        /// <param name="activityId"> activityId to update. </param>
        /// <param name="activity"> replacement Activity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="conversationId"/>, <paramref name="activityId"/>, or <paramref name="activity"/> is null. </exception>
        public Response<ResourceResponse> UpdateActivity(string conversationId, string activityId, Activity activity, CancellationToken cancellationToken = default)
        {
            if (conversationId == null)
            {
                throw new ArgumentNullException(nameof(conversationId));
            }
            if (activityId == null)
            {
                throw new ArgumentNullException(nameof(activityId));
            }
            if (activity == null)
            {
                throw new ArgumentNullException(nameof(activity));
            }

            using var message = CreateUpdateActivityRequest(conversationId, activityId, activity);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                case 202:
                    {
                        ResourceResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = ResourceResponse.DeserializeResourceResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateReplyToActivityRequest(string conversationId, string activityId, Activity activity)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendPath("/v3/conversations/", false);
            uri.AppendPath(conversationId, true);
            uri.AppendPath("/activities/", false);
            uri.AppendPath(activityId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(activity);
            request.Content = content;
            return message;
        }

        /// <summary>
        /// This method allows you to reply to an activity.
        /// 
        /// 
        /// 
        /// This is slightly different from SendToConversation().
        /// 
        /// * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.
        /// 
        /// * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.
        /// 
        /// 
        /// 
        /// Use ReplyToActivity when replying to a specific activity in the conversation.
        /// 
        /// 
        /// 
        /// Use SendToConversation in all other cases.
        /// </summary>
        /// <param name="conversationId"> Conversation ID. </param>
        /// <param name="activityId"> activityId the reply is to (OPTIONAL). </param>
        /// <param name="activity"> Activity to send. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="conversationId"/>, <paramref name="activityId"/>, or <paramref name="activity"/> is null. </exception>
        public async Task<Response<ResourceResponse>> ReplyToActivityAsync(string conversationId, string activityId, Activity activity, CancellationToken cancellationToken = default)
        {
            if (conversationId == null)
            {
                throw new ArgumentNullException(nameof(conversationId));
            }
            if (activityId == null)
            {
                throw new ArgumentNullException(nameof(activityId));
            }
            if (activity == null)
            {
                throw new ArgumentNullException(nameof(activity));
            }

            using var message = CreateReplyToActivityRequest(conversationId, activityId, activity);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                case 202:
                    {
                        ResourceResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = ResourceResponse.DeserializeResourceResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// This method allows you to reply to an activity.
        /// 
        /// 
        /// 
        /// This is slightly different from SendToConversation().
        /// 
        /// * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.
        /// 
        /// * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.
        /// 
        /// 
        /// 
        /// Use ReplyToActivity when replying to a specific activity in the conversation.
        /// 
        /// 
        /// 
        /// Use SendToConversation in all other cases.
        /// </summary>
        /// <param name="conversationId"> Conversation ID. </param>
        /// <param name="activityId"> activityId the reply is to (OPTIONAL). </param>
        /// <param name="activity"> Activity to send. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="conversationId"/>, <paramref name="activityId"/>, or <paramref name="activity"/> is null. </exception>
        public Response<ResourceResponse> ReplyToActivity(string conversationId, string activityId, Activity activity, CancellationToken cancellationToken = default)
        {
            if (conversationId == null)
            {
                throw new ArgumentNullException(nameof(conversationId));
            }
            if (activityId == null)
            {
                throw new ArgumentNullException(nameof(activityId));
            }
            if (activity == null)
            {
                throw new ArgumentNullException(nameof(activity));
            }

            using var message = CreateReplyToActivityRequest(conversationId, activityId, activity);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                case 202:
                    {
                        ResourceResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = ResourceResponse.DeserializeResourceResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateDeleteActivityRequest(string conversationId, string activityId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendPath("/v3/conversations/", false);
            uri.AppendPath(conversationId, true);
            uri.AppendPath("/activities/", false);
            uri.AppendPath(activityId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        /// <summary>
        /// Delete an existing activity.
        /// 
        /// 
        /// 
        /// Some channels allow you to delete an existing activity, and if successful this method will remove the specified activity.
        /// </summary>
        /// <param name="conversationId"> Conversation ID. </param>
        /// <param name="activityId"> activityId to delete. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="conversationId"/> or <paramref name="activityId"/> is null. </exception>
        public async Task<Response> DeleteActivityAsync(string conversationId, string activityId, CancellationToken cancellationToken = default)
        {
            if (conversationId == null)
            {
                throw new ArgumentNullException(nameof(conversationId));
            }
            if (activityId == null)
            {
                throw new ArgumentNullException(nameof(activityId));
            }

            using var message = CreateDeleteActivityRequest(conversationId, activityId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Delete an existing activity.
        /// 
        /// 
        /// 
        /// Some channels allow you to delete an existing activity, and if successful this method will remove the specified activity.
        /// </summary>
        /// <param name="conversationId"> Conversation ID. </param>
        /// <param name="activityId"> activityId to delete. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="conversationId"/> or <paramref name="activityId"/> is null. </exception>
        public Response DeleteActivity(string conversationId, string activityId, CancellationToken cancellationToken = default)
        {
            if (conversationId == null)
            {
                throw new ArgumentNullException(nameof(conversationId));
            }
            if (activityId == null)
            {
                throw new ArgumentNullException(nameof(activityId));
            }

            using var message = CreateDeleteActivityRequest(conversationId, activityId);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetConversationMembersRequest(string conversationId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendPath("/v3/conversations/", false);
            uri.AppendPath(conversationId, true);
            uri.AppendPath("/members", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        /// <summary>
        /// Enumerate the members of a conversation.
        /// 
        /// 
        /// 
        /// This REST API takes a ConversationId and returns an array of ChannelAccount objects representing the members of the conversation.
        /// </summary>
        /// <param name="conversationId"> Conversation ID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="conversationId"/> is null. </exception>
        public async Task<Response<IReadOnlyList<ChannelAccount>>> GetConversationMembersAsync(string conversationId, CancellationToken cancellationToken = default)
        {
            if (conversationId == null)
            {
                throw new ArgumentNullException(nameof(conversationId));
            }

            using var message = CreateGetConversationMembersRequest(conversationId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        IReadOnlyList<ChannelAccount> value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        List<ChannelAccount> array = new List<ChannelAccount>();
                        foreach (var item in document.RootElement.EnumerateArray())
                        {
                            array.Add(ChannelAccount.DeserializeChannelAccount(item));
                        }
                        value = array;
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Enumerate the members of a conversation.
        /// 
        /// 
        /// 
        /// This REST API takes a ConversationId and returns an array of ChannelAccount objects representing the members of the conversation.
        /// </summary>
        /// <param name="conversationId"> Conversation ID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="conversationId"/> is null. </exception>
        public Response<IReadOnlyList<ChannelAccount>> GetConversationMembers(string conversationId, CancellationToken cancellationToken = default)
        {
            if (conversationId == null)
            {
                throw new ArgumentNullException(nameof(conversationId));
            }

            using var message = CreateGetConversationMembersRequest(conversationId);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        IReadOnlyList<ChannelAccount> value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        List<ChannelAccount> array = new List<ChannelAccount>();
                        foreach (var item in document.RootElement.EnumerateArray())
                        {
                            array.Add(ChannelAccount.DeserializeChannelAccount(item));
                        }
                        value = array;
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetConversationMemberRequest(string conversationId, string memberId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendPath("/v3/conversations/", false);
            uri.AppendPath(conversationId, true);
            uri.AppendPath("/members/", false);
            uri.AppendPath(memberId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        /// <summary>
        /// Get a single member of a conversation.
        /// 
        /// 
        /// 
        /// This REST API takes a ConversationId and MemberId and returns a single ChannelAccount object, if that member is found in this conversation.
        /// </summary>
        /// <param name="conversationId"> Conversation ID. </param>
        /// <param name="memberId"> The String to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="conversationId"/> or <paramref name="memberId"/> is null. </exception>
        public async Task<Response<ChannelAccount>> GetConversationMemberAsync(string conversationId, string memberId, CancellationToken cancellationToken = default)
        {
            if (conversationId == null)
            {
                throw new ArgumentNullException(nameof(conversationId));
            }
            if (memberId == null)
            {
                throw new ArgumentNullException(nameof(memberId));
            }

            using var message = CreateGetConversationMemberRequest(conversationId, memberId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ChannelAccount value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = ChannelAccount.DeserializeChannelAccount(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Get a single member of a conversation.
        /// 
        /// 
        /// 
        /// This REST API takes a ConversationId and MemberId and returns a single ChannelAccount object, if that member is found in this conversation.
        /// </summary>
        /// <param name="conversationId"> Conversation ID. </param>
        /// <param name="memberId"> The String to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="conversationId"/> or <paramref name="memberId"/> is null. </exception>
        public Response<ChannelAccount> GetConversationMember(string conversationId, string memberId, CancellationToken cancellationToken = default)
        {
            if (conversationId == null)
            {
                throw new ArgumentNullException(nameof(conversationId));
            }
            if (memberId == null)
            {
                throw new ArgumentNullException(nameof(memberId));
            }

            using var message = CreateGetConversationMemberRequest(conversationId, memberId);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ChannelAccount value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = ChannelAccount.DeserializeChannelAccount(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateDeleteConversationMemberRequest(string conversationId, string memberId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendPath("/v3/conversations/", false);
            uri.AppendPath(conversationId, true);
            uri.AppendPath("/members/", false);
            uri.AppendPath(memberId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        /// <summary>
        /// Deletes a member from a conversation.
        /// 
        /// 
        /// 
        /// This REST API takes a ConversationId and a memberId (of type string) and removes that member from the conversation. If that member was the last member
        /// 
        /// of the conversation, the conversation will also be deleted.
        /// </summary>
        /// <param name="conversationId"> Conversation ID. </param>
        /// <param name="memberId"> ID of the member to delete from this conversation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="conversationId"/> or <paramref name="memberId"/> is null. </exception>
        public async Task<Response> DeleteConversationMemberAsync(string conversationId, string memberId, CancellationToken cancellationToken = default)
        {
            if (conversationId == null)
            {
                throw new ArgumentNullException(nameof(conversationId));
            }
            if (memberId == null)
            {
                throw new ArgumentNullException(nameof(memberId));
            }

            using var message = CreateDeleteConversationMemberRequest(conversationId, memberId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 204:
                    return message.Response;
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Deletes a member from a conversation.
        /// 
        /// 
        /// 
        /// This REST API takes a ConversationId and a memberId (of type string) and removes that member from the conversation. If that member was the last member
        /// 
        /// of the conversation, the conversation will also be deleted.
        /// </summary>
        /// <param name="conversationId"> Conversation ID. </param>
        /// <param name="memberId"> ID of the member to delete from this conversation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="conversationId"/> or <paramref name="memberId"/> is null. </exception>
        public Response DeleteConversationMember(string conversationId, string memberId, CancellationToken cancellationToken = default)
        {
            if (conversationId == null)
            {
                throw new ArgumentNullException(nameof(conversationId));
            }
            if (memberId == null)
            {
                throw new ArgumentNullException(nameof(memberId));
            }

            using var message = CreateDeleteConversationMemberRequest(conversationId, memberId);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 204:
                    return message.Response;
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetConversationPagedMembersRequest(string conversationId, int? pageSize, string continuationToken)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendPath("/v3/conversations/", false);
            uri.AppendPath(conversationId, true);
            uri.AppendPath("/pagedmembers", false);
            if (pageSize != null)
            {
                uri.AppendQuery("pageSize", pageSize.Value, true);
            }
            if (continuationToken != null)
            {
                uri.AppendQuery("continuationToken", continuationToken, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        /// <summary>
        /// Enumerate the members of a conversation one page at a time.
        /// 
        /// 
        /// 
        /// This REST API takes a ConversationId. Optionally a pageSize and/or continuationToken can be provided. It returns a PagedMembersResult, which contains an array
        /// 
        /// of ChannelAccounts representing the members of the conversation and a continuation token that can be used to get more values.
        /// 
        /// 
        /// 
        /// One page of ChannelAccounts records are returned with each call. The number of records in a page may vary between channels and calls. The pageSize parameter can be used as
        /// 
        /// a suggestion. If there are no additional results the response will not contain a continuation token. If there are no members in the conversation the Members will be empty or not present in the response.
        /// 
        /// 
        /// 
        /// A response to a request that has a continuation token from a prior request may rarely return members from a previous request.
        /// </summary>
        /// <param name="conversationId"> Conversation ID. </param>
        /// <param name="pageSize"> Suggested page size. </param>
        /// <param name="continuationToken"> Continuation Token. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="conversationId"/> is null. </exception>
        public async Task<Response<PagedMembersResult>> GetConversationPagedMembersAsync(string conversationId, int? pageSize = null, string continuationToken = null, CancellationToken cancellationToken = default)
        {
            if (conversationId == null)
            {
                throw new ArgumentNullException(nameof(conversationId));
            }

            using var message = CreateGetConversationPagedMembersRequest(conversationId, pageSize, continuationToken);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        PagedMembersResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = PagedMembersResult.DeserializePagedMembersResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Enumerate the members of a conversation one page at a time.
        /// 
        /// 
        /// 
        /// This REST API takes a ConversationId. Optionally a pageSize and/or continuationToken can be provided. It returns a PagedMembersResult, which contains an array
        /// 
        /// of ChannelAccounts representing the members of the conversation and a continuation token that can be used to get more values.
        /// 
        /// 
        /// 
        /// One page of ChannelAccounts records are returned with each call. The number of records in a page may vary between channels and calls. The pageSize parameter can be used as
        /// 
        /// a suggestion. If there are no additional results the response will not contain a continuation token. If there are no members in the conversation the Members will be empty or not present in the response.
        /// 
        /// 
        /// 
        /// A response to a request that has a continuation token from a prior request may rarely return members from a previous request.
        /// </summary>
        /// <param name="conversationId"> Conversation ID. </param>
        /// <param name="pageSize"> Suggested page size. </param>
        /// <param name="continuationToken"> Continuation Token. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="conversationId"/> is null. </exception>
        public Response<PagedMembersResult> GetConversationPagedMembers(string conversationId, int? pageSize = null, string continuationToken = null, CancellationToken cancellationToken = default)
        {
            if (conversationId == null)
            {
                throw new ArgumentNullException(nameof(conversationId));
            }

            using var message = CreateGetConversationPagedMembersRequest(conversationId, pageSize, continuationToken);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        PagedMembersResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = PagedMembersResult.DeserializePagedMembersResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetActivityMembersRequest(string conversationId, string activityId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendPath("/v3/conversations/", false);
            uri.AppendPath(conversationId, true);
            uri.AppendPath("/activities/", false);
            uri.AppendPath(activityId, true);
            uri.AppendPath("/members", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        /// <summary>
        /// Enumerate the members of an activity.
        /// 
        /// 
        /// 
        /// This REST API takes a ConversationId and a ActivityId, returning an array of ChannelAccount objects representing the members of the particular activity in the conversation.
        /// </summary>
        /// <param name="conversationId"> Conversation ID. </param>
        /// <param name="activityId"> Activity ID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="conversationId"/> or <paramref name="activityId"/> is null. </exception>
        public async Task<Response<IReadOnlyList<ChannelAccount>>> GetActivityMembersAsync(string conversationId, string activityId, CancellationToken cancellationToken = default)
        {
            if (conversationId == null)
            {
                throw new ArgumentNullException(nameof(conversationId));
            }
            if (activityId == null)
            {
                throw new ArgumentNullException(nameof(activityId));
            }

            using var message = CreateGetActivityMembersRequest(conversationId, activityId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        IReadOnlyList<ChannelAccount> value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        List<ChannelAccount> array = new List<ChannelAccount>();
                        foreach (var item in document.RootElement.EnumerateArray())
                        {
                            array.Add(ChannelAccount.DeserializeChannelAccount(item));
                        }
                        value = array;
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Enumerate the members of an activity.
        /// 
        /// 
        /// 
        /// This REST API takes a ConversationId and a ActivityId, returning an array of ChannelAccount objects representing the members of the particular activity in the conversation.
        /// </summary>
        /// <param name="conversationId"> Conversation ID. </param>
        /// <param name="activityId"> Activity ID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="conversationId"/> or <paramref name="activityId"/> is null. </exception>
        public Response<IReadOnlyList<ChannelAccount>> GetActivityMembers(string conversationId, string activityId, CancellationToken cancellationToken = default)
        {
            if (conversationId == null)
            {
                throw new ArgumentNullException(nameof(conversationId));
            }
            if (activityId == null)
            {
                throw new ArgumentNullException(nameof(activityId));
            }

            using var message = CreateGetActivityMembersRequest(conversationId, activityId);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        IReadOnlyList<ChannelAccount> value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        List<ChannelAccount> array = new List<ChannelAccount>();
                        foreach (var item in document.RootElement.EnumerateArray())
                        {
                            array.Add(ChannelAccount.DeserializeChannelAccount(item));
                        }
                        value = array;
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateUploadAttachmentRequest(string conversationId, AttachmentData attachmentUpload)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendPath("/v3/conversations/", false);
            uri.AppendPath(conversationId, true);
            uri.AppendPath("/attachments", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(attachmentUpload);
            request.Content = content;
            return message;
        }

        /// <summary>
        /// Upload an attachment directly into a channel&apos;s blob storage.
        /// 
        /// 
        /// 
        /// This is useful because it allows you to store data in a compliant store when dealing with enterprises.
        /// 
        /// 
        /// 
        /// The response is a ResourceResponse which contains an AttachmentId which is suitable for using with the attachments API.
        /// </summary>
        /// <param name="conversationId"> Conversation ID. </param>
        /// <param name="attachmentUpload"> Attachment data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="conversationId"/> or <paramref name="attachmentUpload"/> is null. </exception>
        public async Task<Response<ResourceResponse>> UploadAttachmentAsync(string conversationId, AttachmentData attachmentUpload, CancellationToken cancellationToken = default)
        {
            if (conversationId == null)
            {
                throw new ArgumentNullException(nameof(conversationId));
            }
            if (attachmentUpload == null)
            {
                throw new ArgumentNullException(nameof(attachmentUpload));
            }

            using var message = CreateUploadAttachmentRequest(conversationId, attachmentUpload);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                case 202:
                    {
                        ResourceResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = ResourceResponse.DeserializeResourceResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Upload an attachment directly into a channel&apos;s blob storage.
        /// 
        /// 
        /// 
        /// This is useful because it allows you to store data in a compliant store when dealing with enterprises.
        /// 
        /// 
        /// 
        /// The response is a ResourceResponse which contains an AttachmentId which is suitable for using with the attachments API.
        /// </summary>
        /// <param name="conversationId"> Conversation ID. </param>
        /// <param name="attachmentUpload"> Attachment data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="conversationId"/> or <paramref name="attachmentUpload"/> is null. </exception>
        public Response<ResourceResponse> UploadAttachment(string conversationId, AttachmentData attachmentUpload, CancellationToken cancellationToken = default)
        {
            if (conversationId == null)
            {
                throw new ArgumentNullException(nameof(conversationId));
            }
            if (attachmentUpload == null)
            {
                throw new ArgumentNullException(nameof(attachmentUpload));
            }

            using var message = CreateUploadAttachmentRequest(conversationId, attachmentUpload);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                case 202:
                    {
                        ResourceResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = ResourceResponse.DeserializeResourceResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }
    }
}
